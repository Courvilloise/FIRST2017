// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
#include "GamePadDrive.h"
#include "../Definitions.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
GamePadDrive::GamePadDrive(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::vehicle.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	btnRecordPressed = false;
	btnToggleGatePressed = false;
	posGearGate = Geargate::openGate;
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void GamePadDrive::Initialize() {
	pJoystick = Robot::oi->getJoystick();
	int nAxis = pJoystick->GetAxisCount();
	printf("Number of Gamepad axis = %d\n", nAxis);

	// We start with an open gate
	posGearGate = Geargate::openGate;
	(Robot::geargate.get())->SetGatePosition(posGearGate);
}

// Called repeatedly when this Command is scheduled to run
void GamePadDrive::Execute()
{
//	UpdateRecorder(); // Should be the first function called if we want to record all calls
	UpdateVehicle();
	UpdateCatapult();
	UpdateWinch();
	UpdateGearGate();
}

// Make this return true when this Command no longer needs to run execute()
bool GamePadDrive::IsFinished()
{
    return false;
}

// Called once after isFinished returns true
void GamePadDrive::End()
{
	(Robot::vehicle.get())->Stop();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void GamePadDrive::Interrupted()
{

}

// Update the vehicle based on the gamepad command
void GamePadDrive::UpdateVehicle()
{
	// Used to turn: coefficient (0% to 100% applied on the left and right speed).
	// 0% will fully break the speed (full break).
	// 100% will not break at all the speed
	double leftSpeedCoef = 1.0f;
	double rightSpeedCoef = 1.0f;

	// Get the forward speed (0-1.0)
	// We have to convert a Raw Axis between -1 (not pressed) and +1 to an speed between 0 and 1.0
	double forwadSpeed = (pJoystick->GetRawAxis(VEHICLE_GACHETTE_FORWARD) + 1.0f) / 2.0f;

	// Get the reverse speed (0-1.0)
	// We have to convert a Raw Axis between -1 (not pressed) and +1 to an speed between 0 and 1.0
	double reverseSpeed = (pJoystick->GetRawAxis(VEHICLE_GACHETTE_REVERSE) + 1.0f) / 2.0f;

	// Real speed (the player can press forward and reverse in the same time to speed-up the transition)
	double realSpeed = forwadSpeed - reverseSpeed;

	// Get the direction of the wheel (between -1.0 (full left) to +1.0 (full right))
	double direction = pJoystick->GetRawAxis(VEHICLE_DIRECTION);

	// If the a speed is applied the vehicle will turn while move forward
	if (std::abs(realSpeed) > VEHICLE_AUTORATION_SPEED_THRESHOLD)
	{
		//We like to turn on left (we have to break the left side)
		leftSpeedCoef = (direction < 0.0f ? 1.0f + direction : leftSpeedCoef);
		rightSpeedCoef = (direction > 0.0f ? 1.0f - direction : rightSpeedCoef);

		// Apply the speed on the vehicle
		(Robot::vehicle.get())->Move(realSpeed * leftSpeedCoef, realSpeed * rightSpeedCoef);
	}
	// If the user wants to turn its vehicle on itself (autorotation)
	else if (std::abs(direction) > VEHICLE_MINIMUM_ANGLE_FOR_AUTORATION)
	{
		// As a linear interpolation triggers a very fast auto-rotation, we use a square approach
		double autorotationSpeed = direction * direction * -1.0f;
		// Apply the speed on the vehicle
		(Robot::vehicle.get())->Move(autorotationSpeed, -1.0f * autorotationSpeed);
	}
	else // If no turn, not move forward, we stop!
	{
		(Robot::vehicle.get())->Stop();
	}
}

// Update the catapult based on the gamepad command
void GamePadDrive::UpdateCatapult()
{
	// To control the speed of the catapult we use the POV on the gamepad.
	int povValue = pJoystick->GetPOV(CATAPULT_POV);

	// If the user press up it will increase the speed of the catapult
	if (povValue == CATAPULT_BUTTON_INCREASE_SPEED)
	{
		(Robot::catapult.get())->IncreaseSpeed(CATAPULT_INCREASE_SPEED_DELTA);
		return;
	}

	// If the user press down it will decrease the speed of the catapult
	if (povValue == CATAPULT_BUTTON_DESCREASE_SPEED)
	{
		(Robot::catapult.get())->IncreaseSpeed(-CATAPULT_INCREASE_SPEED_DELTA);
		return;
	}

	// If the user press on left it will stop the catapult
	if (povValue == CATAPULT_BUTTON_STOP_SPEED)
	{
		(Robot::catapult.get())->Stop();
		return;
	}

	// If the user press on right it will restore the previous saved value
	if (povValue == CATAPULT_BUTTON_RESTORE_SPEED)
	{
		// If no previous saved value, the catapult will take a default value we set
		(Robot::catapult.get())->RestoreSavedSpeed(CATAPULT_DEFAULT_RESTORE_SAVED_SPEED);
		return;
	}

	// If the user press on the share button, it will save the current speed
	if (pJoystick->GetRawButton(CATAPULT_BUTTON_RECORD_SPEED))
	{
		(Robot::catapult.get())->SaveCurrentSpeed();
	}
}

void GamePadDrive::UpdateWinch()
{
	// Get the speed of the winch and its direction (between -1.0 (full left) to +1.0 (full right))
	double direction = pJoystick->GetRawAxis(WINCH_DIRECTION);

	(Robot::winch.get())->Move(direction);
}

void GamePadDrive::UpdateGearGate()
{
	if (!btnToggleGatePressed && pJoystick->GetRawButton(GEARGATE_BUTTON_TOGGLE))
	{
		posGearGate = (posGearGate==Geargate::openGate ? Geargate::closeGate : Geargate::openGate);
		(Robot::geargate.get())->SetGatePosition(posGearGate);
		btnToggleGatePressed = true;
	}
	else if (btnToggleGatePressed && !pJoystick->GetRawButton(GEARGATE_BUTTON_TOGGLE))
	{
		btnToggleGatePressed = false;
	}
	(Robot::geargate.get())->Update();
}

// If the user wants to record a sequence of actions
void GamePadDrive::UpdateRecorder()
{
	// If the user wants to start a record or stop it
	if (!btnRecordPressed && pJoystick->GetRawButton(14))
	{
		if (!pActionsRecorder->RecordInProgress())
		{
			pActionsRecorder->Clear();
			pActionsRecorder->StartRecord();
		}
		else
		{
			pActionsRecorder->StopRecord();
		}

		btnRecordPressed = true;

	}
	else // If the user isn't pressing anymore the record button
	{
		btnRecordPressed = false;
	}

	pActionsRecorder->Tick();
}
